// Generated by BUCKLESCRIPT VERSION 5.0.0, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var $$String = require("bs-platform/lib/js/string.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");

function invert(c) {
  switch (c) {
    case 0 : 
        return /* Green */3;
    case 1 : 
        return /* Blue */4;
    case 2 : 
        return /* Purple */5;
    case 3 : 
        return /* Red */0;
    case 4 : 
        return /* Orange */1;
    case 5 : 
        return /* Yellow */2;
    
  }
}

console.log(/* Blue */4);

function stringOfColor(c) {
  switch (c) {
    case 0 : 
        return "Red";
    case 1 : 
        return "Orange";
    case 2 : 
        return "Yellow";
    case 3 : 
        return "Green";
    case 4 : 
        return "Blue";
    case 5 : 
        return "Purple";
    
  }
}

console.log("Purple");

console.log("Inverse of Purple is Yellow");

var bottomLeft = /* Point */[
  -1.0,
  -2.0
];

var topRight = /* Point */[
  7.0,
  6.0
];

var circ = /* Circle */Block.__(1, [
    topRight,
    5.0
  ]);

var rect = /* Rectangle */Block.__(0, [
    bottomLeft,
    topRight
  ]);

var pi = 4.0 * Math.atan(1.0);

function computeArea(s) {
  if (s.tag) {
    return pi * Math.pow(s[1], 2.0);
  } else {
    var match = s[1];
    var match$1 = s[0];
    var width = Math.abs(match[0] - match$1[0]);
    var height = Math.abs(match[1] - match$1[1]);
    return width * height;
  }
}

console.log(computeArea(circ));

console.log(computeArea(rect));

var myIntTree = /* Node */[
  1,
  /* Node */[
    2,
    /* Empty */0,
    /* Empty */0
  ],
  /* Node */[
    3,
    /* Node */[
      4,
      /* Empty */0,
      /* Empty */0
    ],
    /* Empty */0
  ]
];

function computeSum(t) {
  if (t) {
    return (t[0] + computeSum(t[1]) | 0) + computeSum(t[2]) | 0;
  } else {
    return 0;
  }
}

console.log(computeSum(myIntTree));

var myStrTree = /* Node */[
  "a",
  /* Node */[
    "b",
    /* Empty */0,
    /* Empty */0
  ],
  /* Node */[
    "c",
    /* Node */[
      "d",
      /* Empty */0,
      /* Empty */0
    ],
    /* Empty */0
  ]
];

function stringOfTree($staropt$star, stringOfValue, t) {
  var indent = $staropt$star !== undefined ? $staropt$star : 0;
  var indentStr = $$String.make((indent << 1), /* " " */32);
  if (t) {
    return indentStr + (Curry._1(stringOfValue, t[0]) + ("\n" + (stringOfTree(indent + 1 | 0, stringOfValue, t[1]) + stringOfTree(indent + 1 | 0, stringOfValue, t[2]))));
  } else {
    return indentStr + "X\n";
  }
}

console.log(stringOfTree(undefined, (function (x) {
            return x;
          }), myStrTree));

console.log(stringOfTree(undefined, (function (prim) {
            return String(prim);
          }), myIntTree));

var expr = /* Minus */Block.__(1, [
    /* Literal */Block.__(4, [3]),
    /* DividedBy */Block.__(3, [
        /* Literal */Block.__(4, [16]),
        /* Plus */Block.__(0, [
            /* Literal */Block.__(4, [6]),
            /* Literal */Block.__(4, [2])
          ])
      ])
  ]);

function $$eval(e) {
  switch (e.tag | 0) {
    case 0 : 
        return $$eval(e[0]) + $$eval(e[1]) | 0;
    case 1 : 
        return $$eval(e[0]) - $$eval(e[1]) | 0;
    case 2 : 
        return Caml_int32.imul($$eval(e[0]), $$eval(e[1]));
    case 3 : 
        return Caml_int32.div($$eval(e[0]), $$eval(e[1]));
    case 4 : 
        return e[0];
    
  }
}

console.log($$eval(expr));

exports.invert = invert;
exports.stringOfColor = stringOfColor;
exports.bottomLeft = bottomLeft;
exports.topRight = topRight;
exports.circ = circ;
exports.rect = rect;
exports.pi = pi;
exports.computeArea = computeArea;
exports.myIntTree = myIntTree;
exports.computeSum = computeSum;
exports.myStrTree = myStrTree;
exports.stringOfTree = stringOfTree;
exports.expr = expr;
exports.$$eval = $$eval;
/*  Not a pure module */
